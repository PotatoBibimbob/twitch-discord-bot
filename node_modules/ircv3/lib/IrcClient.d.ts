/// <reference types="node" />
import type { Connection, WebSocketConnectionOptions } from '@d-fischer/connection';
import type { LoggerOptions } from '@d-fischer/logger';
import type { ResolvableValue } from '@d-fischer/shared-utils';
import type { EventBinder } from '@d-fischer/typed-event-emitter';
import { EventEmitter } from '@d-fischer/typed-event-emitter';
import type { Capability, ServerCapability } from './Capability/Capability';
import type { Message, MessageConstructor, MessageParamValues } from './Message/Message';
import { MessageCollector } from './Message/MessageCollector';
import { NickChange, Notice, PrivateMessage } from './Message/MessageTypes/Commands';
import type { ServerProperties } from './ServerProperties';
export declare type EventHandler<T extends Message = Message> = (message: T) => void;
export declare type EventHandlerList<T extends Message = Message> = Map<string, EventHandler<T>>;
export interface IrcCredentials {
    nick: string;
    password?: string;
    userName?: string;
    realName?: string;
}
export interface IrcClientConnectionOptions {
    hostName: string;
    port?: number;
    secure?: boolean;
    pingOnInactivity?: number;
    pingTimeout?: number;
    reconnect?: boolean;
}
export interface IrcClientOptions {
    connection: IrcClientConnectionOptions;
    credentials: IrcCredentials;
    channels?: ResolvableValue<string[]>;
    webSocket?: boolean;
    connectionOptions?: WebSocketConnectionOptions;
    channelTypes?: string;
    logger?: Partial<LoggerOptions>;
    nonConformingCommands?: string[];
}
export declare class IrcClient extends EventEmitter {
    protected _connection: Connection;
    protected _registered: boolean;
    protected _options: IrcClientOptions;
    protected _credentials: IrcCredentials;
    protected _supportsCapabilities: boolean;
    protected _events: Map<string, EventHandlerList<Message<any>>>;
    protected _registeredMessageTypes: Map<string, MessageConstructor<any>>;
    /**
     * @eventListener
     */
    onConnect: EventBinder<[]>;
    /**
     * @eventListener
     */
    onRegister: EventBinder<[]>;
    /**
     * @eventListener
     */
    onDisconnect: EventBinder<[manually: boolean, reason?: Error]>;
    /**
     * @eventListener
     */
    onPrivmsg: EventBinder<[target: string, user: string, message: string, msg: PrivateMessage]>;
    /**
     * @eventListener
     */
    onAction: EventBinder<[target: string, user: string, message: string, msg: PrivateMessage]>;
    /**
     * @eventListener
     */
    onNotice: EventBinder<[target: string, user: string, message: string, msg: Notice]>;
    /**
     * @eventListener
     */
    onNickChange: EventBinder<[oldNick: string | undefined, newNick: string, msg: NickChange]>;
    /**
     * @eventListener
     */
    onCtcp: EventBinder<[target: string, user: string, command: string, params: string, msg: PrivateMessage]>;
    /**
     * @eventListener
     */
    onCtcpReply: EventBinder<[target: string, user: string, command: string, params: string, msg: Notice]>;
    /**
     * @eventListener
     */
    onPasswordError: EventBinder<[error: Error]>;
    /**
     * @eventListener
     */
    onAnyMessage: EventBinder<[msg: Message]>;
    protected _serverProperties: ServerProperties;
    protected _supportedFeatures: Record<string, true | string>;
    protected _collectors: MessageCollector[];
    protected _clientCapabilities: Map<string, Capability>;
    protected _serverCapabilities: Map<string, ServerCapability>;
    protected _negotiatedCapabilities: Map<string, ServerCapability>;
    protected _pingOnInactivity: number;
    protected _pingTimeout: number;
    protected _pingCheckTimer?: NodeJS.Timer;
    protected _pingTimeoutTimer?: NodeJS.Timer;
    protected _currentNick: string;
    private readonly _logger;
    private _initialConnectionSetupDone;
    constructor(options: IrcClientOptions);
    receiveLine(line: string): void;
    get serverProperties(): ServerProperties;
    get port(): number;
    pingCheck(): void;
    reconnect(message?: string): Promise<void>;
    registerMessageType(cls: MessageConstructor): void;
    knowsCommand(command: string): boolean;
    getCommandClass(command: string): MessageConstructor | undefined;
    connect(): Promise<void>;
    addCapability(cap: Capability): void;
    registerCapability(cap: Capability): Promise<ServerCapability[] | Error>;
    send(message: Message): void;
    sendRaw(line: string): void;
    onNamedMessage<T extends Message = Message>(commandName: string, handler: EventHandler<T>, handlerName?: string): string;
    onTypedMessage<T extends Message>(type: MessageConstructor<T>, handler: EventHandler<T>, handlerName?: string): string;
    removeMessageListener(handlerName: string): void;
    createMessage<T extends Message<T>>(type: MessageConstructor<T>, params: Partial<MessageParamValues<T>>, tags?: Record<string, string>): T;
    sendMessage<T extends Message<T>>(type: MessageConstructor<T>, params: Partial<MessageParamValues<T>>, tags?: Record<string, string>): void;
    sendMessageAndCaptureReply<T extends Message<T>>(type: MessageConstructor<T>, params: Partial<MessageParamValues<T>>): Promise<Message[]>;
    get isConnected(): boolean;
    get isConnecting(): boolean;
    get isRegistered(): boolean;
    get currentNick(): string;
    /** @private */
    collect(originalMessage: Message, ...types: MessageConstructor[]): MessageCollector;
    /** @private */
    stopCollect(collector: MessageCollector): void;
    join(channel: string, key?: string): void;
    part(channel: string): void;
    quit(message?: string): Promise<void>;
    say(target: string, message: string, tags?: Record<string, string>): void;
    sendCtcp(target: string, type: string, message: string): void;
    action(target: string, message: string): void;
    protected getPassword(currentPassword?: string): Promise<string | undefined>;
    protected registerCoreMessageTypes(): void;
    protected _negotiateCapabilityBatch(capabilities: ServerCapability[][]): Promise<Array<ServerCapability[] | Error>>;
    protected _negotiateCapabilities(capList: ServerCapability[]): Promise<ServerCapability[] | Error>;
    protected _updateCredentials(newCredentials: Partial<IrcCredentials>): void;
    private _setupConnection;
    private _handleReceivedClientNick;
    private _handleEvents;
    private _startPingCheckTimer;
}
